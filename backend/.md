#  Collaborative Task Manager


## Table of Contents

- [Setup Instructions](#setup-instructions)
- [API Contract](#api-contract)
- [Architecture Overview & Design Decisions](#architecture-overview--design-decisions)
- [Socket.IO Integration](#socketio-integration)
- [Trade-offs & Assumptions](#trade-offs--assumptions)

---

## Setup Instructions

### Backend

#### Setup environment variables:

Create a .env file in the root folder:


```bash
# Update the .env file with your own values:
PORT=5000
DB_HOST=localhost
DB_PORT=5432
DB_USER=myuser
DB_PASS=mypassword
DB_NAME=mydatabase
JWT_SECRET=myverysecretkey
JWT_EXPIRES_IN=7d
NODE_ENV=development
```
```bash
# Clone the repository
git clone https://github.com/yourusername/project-name.git
cd project-name/backend

# Install dependencies
npm install

# Run database migrations
npx prisma migrate dev

# Start the backend server
npm run dev
```

### Frontend
```bash
cd ../frontend
npm install
npm run dev 
```

#### Setup environment variables:

Create a .env file in the root folder:


```bash
# Update the .env file with your own values:

ENVIRONMENT = "Development" OR "Production"


DATABASE_URL = postgress db url




JWT_ACCESS_TOKEN_SECRET = 
JWT_REFRESH_TOKEN_SECRET= 

JWT_ACCESS_TOKEN_EXPIRE =  example 2d|2h
JWT_REFRESH_TOKEN_EXPIRE = example 30d|2d|2h|2m


CLIENT_ORIGIN = //client url
```
### API Contract

This document describes the API endpoints for the project.

| Method | Endpoint                  | Description        |
|--------|---------------------------|------------------|
| POST   | `/api/auth/login`      | Login user        |
| POST   | `/api/auth/register`   | Register new user |
| GET   | `/api/auth/accesstoken`   | Get new accesstoken using refreshtoken |
| GET    | `/api/tasks/created`           | Get all tasks     |
| GET    | `/api/tasks/assiigned`           | Get all tasks     |
| GET   | `/api/tasks/oveedue`           | Create new task   |
| POST  | `/api/tasks`       | Ceate task       |
| PUT | `/api/tasks/:id`       | Update task       |
| DELETE | `/api/v1/tasks/:id`       | Delete task       |

### Architecture Overview & Design Decisions

#### Backend

- **Node.js + Express**: Provides REST API endpoints for the application.
- **Prisma ORM with PostgreSQL**: I choose PostgreSQL as database because prisma is Highly Recommended in this assesment and at present i feal comfortable with prostgresql in prisma.
- **Service Layer**: Contains business logic, keeping controllers thin and maintainable,respository for database crud.
- **JWT Authentication**: Uses access and refresh tokens with every request  for secure user authentication 

#### Frontend

- **React + Vite**: Lightweight and fast frontend setup.
- **React Query**: Manages server state and data fetching efficiently.
- **Socket.IO Client**: Enables real-time updates for tasks and notifications.

### How Socket.IO Works

Socket.IO is used in this project to provide **real-time updates** for tasks and notifications. The workflow is designed to ensure that only authenticated users receive relevant updates and that connections are properly managed. Here's how it works step by step:

1. **Authenticate User**  
   When a user connects to the Socket.IO server, their authentication token is verified. This ensures that only valid and logged-in users can establish a socket connection. Unauthorized users are denied access to real-time events.

2. **Save Connection Info**  
   Once authenticated, the user's connection information (such as their `socket.id`) is stored in a global variable  using a **Setter function**. This store keeps track of all active user connections. The stored connections can later be accessed from anywhere in the backend using a **Getter function**, making it easy to target specific users when emitting events.

3. **Emit Events**  
   Whenever a task is created, updated, or deleted, the backend emits real-time events to the relevant connected users. By checking the stored connection information, the server can ensure that each user receives updates only for tasks that concern them. This allows for live updates in the frontend without needing to refresh the page or poll the server continuously.

4. **Cleanup**  
   When a user disconnects (e.g., closes the browser or loses connection), their socket connection information is removed from the global store using a **removal function**. This keeps the in-memory store clean and prevents unnecessary memory usage or attempts to send events to disconnected users.

5. **Benefits**  
   - Ensures secure real-time communication by authenticating users before connection.  
   - Efficiently manages multiple user connections in a centralized store.  
   - Provides instant updates to the frontend, improving user experience for task management and notifications.
     
### Bonus Challenges
- **Task Status Update Logs:**  
  Every time a user updates a task, the change is saved as a log in the database. This allows tracking of task history and changes over time.  
  **Note:** Currently, there is no API endpoint to fetch these logs, so they are stored for internal tracking or future use.
  
### Extra Features Implemented
- **Flexible Task Assignment:** Users can create tasks without assigning them to anyone initially. They can later assign or remove users through the update form.  
- **Controlled Task Updates:** Assigned users can update almost all properties of a task, while unassigned users are restricted from making any updates.  
- **Logout Functionality:** Users can securely log out, ensuring their sessions are safely terminated.  

### Trade-offs & Assumption
- Currently, user socket connections are stored in an in-memory variable. This works well for small-scale applications, but for larger-scale apps, this approach may consume a lot of memory. To handle a large number of concurrent connections efficiently, a proper caching mechanism (like Redis) would be recommended.




